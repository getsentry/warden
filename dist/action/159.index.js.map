{"version":3,"file":"159.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAWA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAUA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA","sources":[".././src/skills/remote.ts"],"sourcesContent":["import { existsSync, mkdirSync, readFileSync, writeFileSync, rmSync, renameSync, readdirSync, statSync } from 'node:fs';\nimport { homedir } from 'node:os';\nimport { dirname, join } from 'node:path';\nimport { execFileSync } from 'node:child_process';\nimport { z } from 'zod';\nimport { loadSkillFromMarkdown, SkillLoaderError } from './loader.js';\nimport type { SkillDefinition } from '../config/schema.js';\n\n/** Default TTL for unpinned remote skills: 24 hours */\nconst DEFAULT_TTL_SECONDS = 86400;\n\n/** Schema for a single remote entry in state.json */\nconst RemoteEntrySchema = z.object({\n  sha: z.string(),\n  fetchedAt: z.string().datetime(),\n});\n\n/** Schema for the entire state.json file */\nconst RemoteStateSchema = z.object({\n  remotes: z.record(z.string(), RemoteEntrySchema),\n});\n\nexport type RemoteEntry = z.infer<typeof RemoteEntrySchema>;\nexport type RemoteState = z.infer<typeof RemoteStateSchema>;\n\n/** Schema for a plugin in marketplace.json */\nconst MarketplacePluginSchema = z.object({\n  name: z.string(),\n  source: z.string(),\n  description: z.string().optional(),\n  category: z.string().optional(),\n});\n\n/** Schema for .claude-plugin/marketplace.json */\nconst MarketplaceConfigSchema = z.object({\n  $schema: z.string().optional(),\n  name: z.string(),\n  description: z.string().optional(),\n  plugins: z.array(MarketplacePluginSchema),\n});\n\ntype MarketplaceConfig = z.infer<typeof MarketplaceConfigSchema>;\n\n/** Parsed remote reference */\nexport interface ParsedRemoteRef {\n  owner: string;\n  repo: string;\n  sha?: string;\n}\n\n/**\n * Normalize a GitHub URL to owner/repo format.\n * Returns null if the input is not a recognized GitHub URL.\n *\n * Supports:\n * - https://github.com/owner/repo\n * - https://github.com/owner/repo.git\n * - git@github.com:owner/repo.git\n */\nfunction normalizeGitHubUrl(input: string): string | null {\n  // HTTPS URL: https://github.com/owner/repo or https://github.com/owner/repo.git\n  const httpsMatch = input.match(/^https?:\\/\\/github\\.com\\/([^/]+)\\/([^/@]+?)(?:\\.git)?$/);\n  if (httpsMatch) {\n    return `${httpsMatch[1]}/${httpsMatch[2]}`;\n  }\n\n  // SSH URL: git@github.com:owner/repo.git\n  const sshMatch = input.match(/^git@github\\.com:([^/]+)\\/([^/@]+?)(?:\\.git)?$/);\n  if (sshMatch) {\n    return `${sshMatch[1]}/${sshMatch[2]}`;\n  }\n\n  return null;\n}\n\n/**\n * Parse a remote reference string into its components.\n * Supports formats:\n * - \"owner/repo\" or \"owner/repo@sha\"\n * - \"https://github.com/owner/repo\" or \"https://github.com/owner/repo@sha\"\n * - \"https://github.com/owner/repo.git\" or \"https://github.com/owner/repo.git@sha\"\n * - \"git@github.com:owner/repo.git\" or \"git@github.com:owner/repo.git@sha\"\n */\nexport function parseRemoteRef(ref: string): ParsedRemoteRef {\n  let inputRef = ref;\n  let sha: string | undefined;\n\n  // Extract SHA suffix from the input before URL normalization.\n  // The SHA is always at the end, after a @ that follows the repo name.\n  // For git@github.com URLs, we need to find the @ after the colon.\n  if (ref.startsWith('git@')) {\n    const colonIndex = ref.indexOf(':');\n    if (colonIndex !== -1) {\n      const afterColon = ref.slice(colonIndex + 1);\n      const shaAtIndex = afterColon.lastIndexOf('@');\n      if (shaAtIndex !== -1) {\n        sha = afterColon.slice(shaAtIndex + 1);\n        inputRef = ref.slice(0, colonIndex + 1 + shaAtIndex);\n      }\n    }\n  } else {\n    const lastAtIndex = ref.lastIndexOf('@');\n    if (lastAtIndex !== -1) {\n      const potentialSha = ref.slice(lastAtIndex + 1);\n      // SHA should not contain : or / (those would indicate URL structure)\n      if (!potentialSha.includes(':') && !potentialSha.includes('/')) {\n        if (!potentialSha) {\n          throw new SkillLoaderError(`Invalid remote ref: ${ref} (empty SHA after @)`);\n        }\n        sha = potentialSha;\n        inputRef = ref.slice(0, lastAtIndex);\n      }\n    }\n  }\n\n  // Normalize GitHub URLs to owner/repo format\n  const repoPath = normalizeGitHubUrl(inputRef) ?? inputRef;\n\n  const slashIndex = repoPath.indexOf('/');\n  if (slashIndex === -1) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (expected owner/repo format)`);\n  }\n\n  const owner = repoPath.slice(0, slashIndex);\n  const repo = repoPath.slice(slashIndex + 1);\n\n  if (!owner || !repo) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (empty owner or repo)`);\n  }\n\n  if (repo.includes('/')) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (repo name cannot contain /)`);\n  }\n\n  // Security: Prevent git flag injection by rejecting values starting with '-'\n  if (owner.startsWith('-')) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (owner cannot start with -)`);\n  }\n  if (repo.startsWith('-')) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (repo cannot start with -)`);\n  }\n  if (sha?.startsWith('-')) {\n    throw new SkillLoaderError(`Invalid remote ref: ${ref} (SHA cannot start with -)`);\n  }\n\n  return { owner, repo, sha };\n}\n\n/**\n * Format a parsed remote ref back to string format.\n */\nexport function formatRemoteRef(parsed: ParsedRemoteRef): string {\n  const base = `${parsed.owner}/${parsed.repo}`;\n  return parsed.sha ? `${base}@${parsed.sha}` : base;\n}\n\n/**\n * Get the base directory for caching remote skills.\n * Respects WARDEN_STATE_DIR environment variable.\n * Default: ~/.local/warden/skills/\n */\nexport function getSkillsCacheDir(): string {\n  const stateDir = process.env['WARDEN_STATE_DIR'];\n  if (stateDir) {\n    return join(stateDir, 'skills');\n  }\n  return join(homedir(), '.local', 'warden', 'skills');\n}\n\n/**\n * Get the cache path for a specific remote ref.\n * - Unpinned: ~/.local/warden/skills/owner/repo/\n * - Pinned: ~/.local/warden/skills/owner/repo@sha/\n */\nexport function getRemotePath(ref: string): string {\n  const parsed = parseRemoteRef(ref);\n  const cacheDir = getSkillsCacheDir();\n\n  if (parsed.sha) {\n    return join(cacheDir, parsed.owner, `${parsed.repo}@${parsed.sha}`);\n  }\n  return join(cacheDir, parsed.owner, parsed.repo);\n}\n\n/**\n * Get the path to the state.json file.\n */\nexport function getStatePath(): string {\n  return join(getSkillsCacheDir(), 'state.json');\n}\n\n/**\n * Load the remote state from state.json.\n * Returns an empty state if the file doesn't exist.\n */\nexport function loadState(): RemoteState {\n  const statePath = getStatePath();\n\n  if (!existsSync(statePath)) {\n    return { remotes: {} };\n  }\n\n  try {\n    const content = readFileSync(statePath, 'utf-8');\n    const data = JSON.parse(content);\n    return RemoteStateSchema.parse(data);\n  } catch (error) {\n    // If state is corrupted, start fresh\n    const message = error instanceof Error ? error.message : String(error);\n    console.warn(`Warning: Failed to load state.json, starting fresh: ${message}`);\n    return { remotes: {} };\n  }\n}\n\n/**\n * Save the remote state to state.json.\n * Uses atomic write (write to temp, then rename).\n */\nexport function saveState(state: RemoteState): void {\n  const statePath = getStatePath();\n  const stateDir = dirname(statePath);\n\n  // Ensure directory exists\n  if (!existsSync(stateDir)) {\n    mkdirSync(stateDir, { recursive: true });\n  }\n\n  // Write atomically\n  const tempPath = `${statePath}.tmp`;\n  writeFileSync(tempPath, JSON.stringify(state, null, 2), 'utf-8');\n\n  // Rename is atomic on most filesystems\n  renameSync(tempPath, statePath);\n}\n\n/**\n * Get the TTL for remote skill cache in seconds.\n * Respects WARDEN_SKILL_CACHE_TTL environment variable.\n */\nexport function getCacheTtlSeconds(): number {\n  const envTtl = process.env['WARDEN_SKILL_CACHE_TTL'];\n  if (envTtl) {\n    const parsed = parseInt(envTtl, 10);\n    if (!isNaN(parsed) && parsed > 0) {\n      return parsed;\n    }\n  }\n  return DEFAULT_TTL_SECONDS;\n}\n\n/**\n * Check if an unpinned remote ref needs to be refreshed.\n * Pinned refs (with @sha) never need refresh.\n */\nexport function shouldRefresh(ref: string, state: RemoteState): boolean {\n  const parsed = parseRemoteRef(ref);\n\n  // Pinned refs are immutable - never refresh\n  if (parsed.sha) {\n    return false;\n  }\n\n  const entry = state.remotes[ref];\n  if (!entry) {\n    return true; // Not cached, needs fetch\n  }\n\n  const fetchedAt = new Date(entry.fetchedAt).getTime();\n  const now = Date.now();\n  const ttl = getCacheTtlSeconds() * 1000;\n\n  return now - fetchedAt > ttl;\n}\n\nexport interface FetchRemoteOptions {\n  /** Force refresh even if cache is valid */\n  force?: boolean;\n  /** Skip network operations - only use cache */\n  offline?: boolean;\n  /** Callback for progress messages */\n  onProgress?: (message: string) => void;\n}\n\n/**\n * Execute a git command and return stdout.\n * Uses execFileSync to avoid shell injection vulnerabilities.\n * Throws SkillLoaderError on failure.\n */\nfunction execGit(args: string[], options?: { cwd?: string }): string {\n  try {\n    return execFileSync('git', args, {\n      encoding: 'utf-8',\n      cwd: options?.cwd,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new SkillLoaderError(`Git command failed: git ${args.join(' ')}: ${message}`);\n  }\n}\n\n/**\n * Clone or update a remote repository to the cache.\n * Returns the SHA of the fetched commit.\n */\nexport async function fetchRemote(ref: string, options: FetchRemoteOptions = {}): Promise<string> {\n  const { force = false, offline = false, onProgress } = options;\n  const parsed = parseRemoteRef(ref);\n  const remotePath = getRemotePath(ref);\n  const state = loadState();\n\n  const isPinned = !!parsed.sha;\n  const isCached = existsSync(remotePath);\n  const needsRefresh = shouldRefresh(ref, state);\n\n  // Check if we have a valid cache (directory exists AND state entry exists)\n  const stateEntry = state.remotes[ref];\n  const hasValidCache = isCached && !!stateEntry;\n\n  // Handle offline mode\n  if (offline) {\n    if (hasValidCache) {\n      return stateEntry.sha;\n    }\n    throw new SkillLoaderError(`Remote skill not cached and offline mode enabled: ${ref}`);\n  }\n\n  // Pinned + valid cache = use cache (SHA is immutable)\n  if (isPinned && hasValidCache && !force && parsed.sha) {\n    return parsed.sha;\n  }\n\n  // Unpinned + valid cache + fresh = use cache\n  if (!isPinned && hasValidCache && !needsRefresh && !force) {\n    return stateEntry.sha;\n  }\n\n  const repoUrl = `https://github.com/${parsed.owner}/${parsed.repo}.git`;\n\n  // Clone or update\n  if (!isCached) {\n    onProgress?.(`Cloning ${ref}...`);\n\n    // Ensure parent directory exists\n    const parentDir = dirname(remotePath);\n    if (!existsSync(parentDir)) {\n      mkdirSync(parentDir, { recursive: true });\n    }\n\n    // Clone with minimal depth for unpinned refs\n    // Note: '--' separates flags from positional args to prevent flag injection\n    if (isPinned && parsed.sha) {\n      // For pinned refs, we need full history to checkout the specific SHA\n      // Use a shallow clone then deepen if needed\n      execGit(['clone', '--depth=1', '--', repoUrl, remotePath]);\n\n      try {\n        // Try to checkout the pinned SHA\n        // Note: 'checkout' without '--' treats arg as ref; with '--' it's a file path\n        execGit(['fetch', '--depth=1', 'origin', '--', parsed.sha], { cwd: remotePath });\n        execGit(['checkout', parsed.sha], { cwd: remotePath });\n      } catch {\n        // If SHA not found, do a full fetch and retry\n        execGit(['fetch', '--unshallow'], { cwd: remotePath });\n        execGit(['checkout', parsed.sha], { cwd: remotePath });\n      }\n    } else if (!isPinned) {\n      // For unpinned refs, shallow clone of default branch\n      execGit(['clone', '--depth=1', '--', repoUrl, remotePath]);\n    }\n  } else {\n    // Update existing cache\n    onProgress?.(`Updating ${ref}...`);\n\n    if (!isPinned) {\n      // For unpinned refs, pull latest\n      execGit(['fetch', '--depth=1', 'origin'], { cwd: remotePath });\n      execGit(['reset', '--hard', 'origin/HEAD'], { cwd: remotePath });\n    }\n    // Pinned refs don't need updates - SHA is immutable\n  }\n\n  // Get the current HEAD SHA\n  const sha = execGit(['rev-parse', 'HEAD'], { cwd: remotePath });\n\n  // Update state\n  state.remotes[ref] = {\n    sha,\n    fetchedAt: new Date().toISOString(),\n  };\n  saveState(state);\n\n  return sha;\n}\n\nexport interface DiscoveredRemoteSkill {\n  name: string;\n  description: string;\n  path: string;\n  /** Plugin name for marketplace format skills */\n  pluginName?: string;\n}\n\n/**\n * Parse marketplace.json from a remote repository if it exists.\n * Returns null if the file doesn't exist or is invalid.\n */\nfunction parseMarketplaceConfig(remotePath: string): MarketplaceConfig | null {\n  const marketplacePath = join(remotePath, '.claude-plugin', 'marketplace.json');\n\n  if (!existsSync(marketplacePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(marketplacePath, 'utf-8');\n    const data = JSON.parse(content);\n    return MarketplaceConfigSchema.parse(data);\n  } catch {\n    // Invalid or malformed marketplace.json - fall back to traditional discovery\n    return null;\n  }\n}\n\n/** Directories to search for skills in remote repositories */\nconst REMOTE_SKILL_DIRECTORIES = [\n  '',               // root level\n  'skills',         // skills/ subdirectory\n  '.warden/skills', // Warden-specific\n  '.agents/skills', // General agent skills\n  '.claude/skills', // Claude Code skills\n];\n\n/**\n * Discover skills using traditional directory layout.\n * Searches root level, skills/, and conventional skill directories.\n */\nasync function discoverTraditionalSkills(remotePath: string): Promise<DiscoveredRemoteSkill[]> {\n  const skills: DiscoveredRemoteSkill[] = [];\n  const seenNames = new Set<string>();\n\n  for (const subdir of REMOTE_SKILL_DIRECTORIES) {\n    const searchPath = subdir ? join(remotePath, subdir) : remotePath;\n    if (!existsSync(searchPath)) continue;\n\n    const entries = readdirSync(searchPath);\n\n    for (const entry of entries) {\n      if (entry.startsWith('.')) continue;\n\n      const entryPath = join(searchPath, entry);\n      const stat = statSync(entryPath);\n\n      if (stat.isDirectory()) {\n        const skillMdPath = join(entryPath, 'SKILL.md');\n        if (existsSync(skillMdPath)) {\n          try {\n            const skill = await loadSkillFromMarkdown(skillMdPath);\n            // First occurrence wins (root takes precedence over skills/)\n            if (!seenNames.has(skill.name)) {\n              seenNames.add(skill.name);\n              skills.push({\n                name: skill.name,\n                description: skill.description,\n                path: entryPath,\n              });\n            }\n          } catch {\n            // Skip invalid skill directories\n          }\n        }\n      }\n    }\n  }\n\n  return skills;\n}\n\n/**\n * Discover skills using marketplace format.\n * Searches plugins/{plugin}/skills/ for each plugin defined in marketplace.json.\n */\nasync function discoverMarketplaceSkills(\n  remotePath: string,\n  config: MarketplaceConfig\n): Promise<DiscoveredRemoteSkill[]> {\n  const skills: DiscoveredRemoteSkill[] = [];\n  const seenNames = new Set<string>();\n\n  for (const plugin of config.plugins) {\n    // Resolve plugin source path (e.g., \"./plugins/sentry-skills\" -> \"plugins/sentry-skills\")\n    const pluginSource = plugin.source.replace(/^\\.\\//, '');\n    const skillsPath = join(remotePath, pluginSource, 'skills');\n\n    if (!existsSync(skillsPath)) continue;\n\n    const entries = readdirSync(skillsPath);\n\n    for (const entry of entries) {\n      if (entry.startsWith('.')) continue;\n\n      const entryPath = join(skillsPath, entry);\n      const stat = statSync(entryPath);\n\n      if (stat.isDirectory()) {\n        const skillMdPath = join(entryPath, 'SKILL.md');\n        if (existsSync(skillMdPath)) {\n          try {\n            const skill = await loadSkillFromMarkdown(skillMdPath);\n            // First plugin wins for duplicate skill names\n            if (!seenNames.has(skill.name)) {\n              seenNames.add(skill.name);\n              skills.push({\n                name: skill.name,\n                description: skill.description,\n                path: entryPath,\n                pluginName: plugin.name,\n              });\n            }\n          } catch {\n            // Skip invalid skill directories\n          }\n        }\n      }\n    }\n  }\n\n  return skills;\n}\n\n/**\n * Discover all skills in a cached remote repository.\n * Detects format and delegates to appropriate discovery function:\n * - If .claude-plugin/marketplace.json exists, uses marketplace discovery\n * - Otherwise, uses traditional discovery (root, skills/, .warden/skills, etc.)\n */\nexport async function discoverRemoteSkills(ref: string): Promise<DiscoveredRemoteSkill[]> {\n  const remotePath = getRemotePath(ref);\n\n  if (!existsSync(remotePath)) {\n    throw new SkillLoaderError(`Remote not cached: ${ref}. Run fetch first.`);\n  }\n\n  // Check for marketplace format\n  const marketplaceConfig = parseMarketplaceConfig(remotePath);\n  if (marketplaceConfig) {\n    return discoverMarketplaceSkills(remotePath, marketplaceConfig);\n  }\n\n  // Fall back to traditional discovery\n  return discoverTraditionalSkills(remotePath);\n}\n\n/**\n * Resolve a skill from a remote repository.\n * Ensures the remote is fetched/cached, then loads the skill.\n * Matches by skill name (from SKILL.md), not directory name.\n */\nexport async function resolveRemoteSkill(\n  ref: string,\n  skillName: string,\n  options: FetchRemoteOptions = {}\n): Promise<SkillDefinition> {\n  await fetchRemote(ref, options);\n\n  const availableSkills = await discoverRemoteSkills(ref);\n  const match = availableSkills.find((s) => s.name === skillName);\n\n  if (match) {\n    return loadSkillFromMarkdown(join(match.path, 'SKILL.md'));\n  }\n\n  if (availableSkills.length === 0) {\n    throw new SkillLoaderError(`No skills found in remote: ${ref}`);\n  }\n\n  throw new SkillLoaderError(\n    `Skill '${skillName}' not found in remote: ${ref}. Available skills: ${availableSkills.map((s) => s.name).join(', ')}`\n  );\n}\n\n/**\n * Remove a remote from the cache.\n */\nexport function removeRemote(ref: string): void {\n  const remotePath = getRemotePath(ref);\n\n  if (existsSync(remotePath)) {\n    rmSync(remotePath, { recursive: true, force: true });\n  }\n\n  const state = loadState();\n  const { [ref]: _removed, ...remainingRemotes } = state.remotes;\n  state.remotes = remainingRemotes;\n  saveState(state);\n}\n\n/**\n * List all cached remotes with their metadata.\n */\nexport function listCachedRemotes(): { ref: string; entry: RemoteEntry }[] {\n  const state = loadState();\n  return Object.entries(state.remotes).map(([ref, entry]) => ({ ref, entry }));\n}\n"],"names":[],"sourceRoot":""}